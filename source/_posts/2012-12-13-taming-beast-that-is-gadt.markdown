---
layout: post
title: "Taming the beast that is GADT  "
date: 2012-12-13
comments: false
categories:
 - ocaml
 - format
 - camlp4
 - gadt
 - c
 - dsl
 - objective-c
---

<div class='post'>
<style type="text/css">.ocaml-code {   background: #E0F0FF;   color:#222222" } </style> For the past few weeks I have been trying to write a little embedded DSL. The goal is to be able to easily generate bindings between OCaml and C, and maybe Objective-C, too.<br /><br />So far, I have written a simplified representation of C <i>[1]</i> using normal algebraic datatypes. This will allow me to have a loosely-typed&nbsp;intermediate representation, which I can then pretty print. The pretty printer I have implemented using the <i>Format</i> module from <i>stdlib</i>. It already supports types, expressions and statements, but no global definitions and declarations, yet.<br />To print OCaml code, I will use <i>Format</i> again for a first draft, and switch to CamlP4, should the need arise. I briefly considered using CamlP4 quotations for the whole project, but that would necessitate quotations and parsers for each language to bind. Unfortunately, my parser-fu is not up-to scratch, and the sparse documentation for CamlP4 is not helping either. [2] Maybe it is time to dust of the dragon books?<br /><br />The EDSL that I am currently working on uses a feature just recently introduced with OCaml 4.0: generalized algebraic datatypes, or <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual021.html#toc85">GADT</a> for short. This will allow me to use OCaml's type-inference and -checking for the FFI description language. So basically, I'm writing a strongly-typed code generator in OCaml. When run, this generator will in turn create the necessary OCaml and C code, constituting a particular OCaml foreign function interface.<br /><br />One thing I've come to notice when working with GADTs is that it helps to have as much type annotations as possible in the beginning. Only later on, when everything is working, can some annotations be removed. Otherwise, there will be a lot of strange type errors. Which for a mere software engineer like me are sometimes hard to understand. With type annotations, the error messages are usually much clearer.<br />I've found that recursive functions help a lot, as they are probably easiest to annotate and allow me to structure the code a little better. A concrete example is the following <i>bind </i>function:<br /><br /><pre class="ocaml-code">let rec bind : type s r. (r,s) fn -&gt; s -&gt; r = fun fs f -&gt; <br />  match fs with<br />  | FVoid _ -&gt; f<br />  | FLambda (t,n,fs') -&gt; let x = XId (t,n) in bind fs' (f x)</pre><br />With mutually recursive functions and additional type informations, the above example would look like this:<br /><br /><pre class="ocaml-code">let rec bind :<br />  type s r. (r,s) fn -> s -> r =<br />      fun fs f -> <br />        match fs with<br />        | FVoid _ -> bind0 f<br />        | FLambda (t,n,fs') -> bind1 t n fs' f<br />and bind0 :<br />  type a. a x -> a x =<br />      fun f -> f<br />and bind1 :<br />  type a r s. a t -> string -> (r x, s) fn -> (a x -> s) -> r x = <br />      fun t n fs f -><br />        let x = XId (t,n) in bind fs (f x)</pre><div><br /></div><div>With the following types, interested readers should be able to toy around with the above functions in OCaml (Version 4.0 is required):<br /><br /></div><pre class="ocaml-code">(* Type of a value *)<br />type _ t =<br />  | TVoid       : unit t<br />  | TInt        : int t<br />  | TFun        : ('r,'a) fn                    -&gt; ('r,'a) fn t <br />(* Values / expressions *)<br />and _ x =<br />  | XInt        : int                           -&gt; int x<br />  | XId         : 'a t * id                     -&gt; 'a x<br />  | XAdd        : int x * int x                 -&gt; int x<br />  | XApp0       : ('r x,'r x) fn x              -&gt; 'r x <br />  | XApp1       : ('r,'a x -&gt; 'b) fn x * 'a x   -&gt; ('r,'b) fn x<br />(* Function signature *)<br />and (_,_) fn =<br />  | FVoid       : 'r t                          -&gt; ('r x,'r x) fn<br />  | FLambda     : 'a t * id * ('r x,'b) fn      -&gt; ('r x,'a x -&gt; 'b) fn<br />(* Identifier *)<br />and id = string</pre><div><br /></div><div><br /></div><b>Footnotes &amp; References:</b><br /><br /><ol><li>I am aware of <a href="http://kerneis.github.com/cil/">CIL</a>, but it seems to heavyweight for my purposes, and does not support Objective-C. And I view this whole exercise as a learning experience.</li><li>There is now at least a <a href="http://brion.inria.fr/gallium/index.php/Camlp4">wiki for CamlP4</a>. And Andrei Formiga has a <a href="http://andreiformiga.com/blog/?p=99">nice collection of links on the subject</a>.</li></ol></div>
